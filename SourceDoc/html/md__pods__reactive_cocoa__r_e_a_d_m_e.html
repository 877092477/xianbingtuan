<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FnuoOS导购返利: ReactiveCocoa [![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon120.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FnuoOS导购返利
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">FnuoOS导购返利模板</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ReactiveCocoa [![Carthage compatible](<a href="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat">https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat</a>)](<a href="https://github.com/Carthage/Carthage">https://github.com/Carthage/Carthage</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ReactiveCocoa (RAC) is an Objective-C framework inspired by [Functional Reactive Programming][]. It provides APIs for <b>composing and transforming streams of values</b>.</p>
<p>If you're already familiar with functional reactive programming or know the basic premise of ReactiveCocoa, check out the [Documentation][] folder for a framework overview and more in-depth information about how it all works in practice.</p>
<h2>New to ReactiveCocoa?</h2>
<p>ReactiveCocoa is documented like crazy, and there's a wealth of introductory material available to explain what RAC is and how you can use it.</p>
<p>If you want to learn more, we recommend these resources, roughly in order:</p>
<ol type="1">
<li><a href="#introduction">Introduction</a></li>
</ol>
<ol type="1">
<li><a href="#when-to-use-reactivecocoa">When to use ReactiveCocoa</a></li>
</ol>
<ol type="1">
<li>Framework Overview</li>
</ol>
<ol type="1">
<li>Basic Operators</li>
</ol>
<ol type="1">
<li>[Header documentation](ReactiveCocoa)</li>
</ol>
<ol type="1">
<li>Previously answered <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/wiki">Stack Overflow</a> questions and <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues?labels=question&amp;state=closed">GitHub issues</a></li>
</ol>
<ol type="1">
<li>The rest of the [Documentation][] folder</li>
</ol>
<ol type="1">
<li><a href="https://leanpub.com/iosfrp/">Functional Reactive Programming on iOS</a> (eBook)</li>
</ol>
<p>If you have any further questions, please feel free to <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/new">file an issue</a>.</p>
<h2>Introduction</h2>
<p>ReactiveCocoa is inspired by <a href="http://blog.maybeapps.com/post/42894317939/input-and-output">functional reactive programming</a>. Rather than using mutable variables which are replaced and modified in-place, RAC provides signals (represented by <code><a class="el" href="interface_r_a_c_signal.html">RACSignal</a></code>) that capture present and future values.</p>
<p>By chaining, combining, and reacting to signals, software can be written declaratively, without the need for code that continually observes and updates values.</p>
<p>For example, a text field can be bound to the latest time, even as it changes, instead of using additional code that watches the clock and updates the text field every second. It works much like KVO, but with blocks instead of overriding <code>-observeValueForKeyPath:ofObject:change:context:</code>.</p>
<p>Signals can also represent asynchronous operations, much like [futures and promises][]. This greatly simplifies asynchronous software, including networking code.</p>
<p>One of the major advantages of RAC is that it provides a single, unified approach to dealing with asynchronous behaviors, including delegate methods, callback blocks, target-action mechanisms, notifications, and KVO.</p>
<p>Here's a simple example:</p>
<div class="fragment"><div class="line">// When self.username changes, logs the new name to the console.</div><div class="line">//</div><div class="line">// RACObserve(self, username) creates a new RACSignal that sends the current</div><div class="line">// value of self.username, then the new value whenever it changes.</div><div class="line">// -subscribeNext: will execute the block whenever the signal sends a value.</div><div class="line">[RACObserve(self, username) subscribeNext:^(NSString *newName) {</div><div class="line">    NSLog(@&quot;%@&quot;, newName);</div><div class="line">}];</div></div><!-- fragment --><p>But unlike KVO notifications, signals can be chained together and operated on:</p>
<div class="fragment"><div class="line">// Only logs names that starts with &quot;j&quot;.</div><div class="line">//</div><div class="line">// -filter returns a new RACSignal that only sends a new value when its block</div><div class="line">// returns YES.</div><div class="line">[[RACObserve(self, username)</div><div class="line">    filter:^(NSString *newName) {</div><div class="line">        return [newName hasPrefix:@&quot;j&quot;];</div><div class="line">    }]</div><div class="line">    subscribeNext:^(NSString *newName) {</div><div class="line">        NSLog(@&quot;%@&quot;, newName);</div><div class="line">    }];</div></div><!-- fragment --><p>Signals can also be used to derive state. Instead of observing properties and setting other properties in response to the new values, RAC makes it possible to express properties in terms of signals and operations:</p>
<div class="fragment"><div class="line">// Creates a one-way binding so that self.createEnabled will be</div><div class="line">// true whenever self.password and self.passwordConfirmation</div><div class="line">// are equal.</div><div class="line">//</div><div class="line">// RAC() is a macro that makes the binding look nicer.</div><div class="line">// </div><div class="line">// +combineLatest:reduce: takes an array of signals, executes the block with the</div><div class="line">// latest value from each signal whenever any of them changes, and returns a new</div><div class="line">// RACSignal that sends the return value of that block as values.</div><div class="line">RAC(self, createEnabled) = [RACSignal </div><div class="line">    combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ] </div><div class="line">    reduce:^(NSString *password, NSString *passwordConfirm) {</div><div class="line">        return @([passwordConfirm isEqualToString:password]);</div><div class="line">    }];</div></div><!-- fragment --><p>Signals can be built on any stream of values over time, not just KVO. For example, they can also represent button presses:</p>
<div class="fragment"><div class="line">// Logs a message whenever the button is pressed.</div><div class="line">//</div><div class="line">// RACCommand creates signals to represent UI actions. Each signal can</div><div class="line">// represent a button press, for example, and have additional work associated</div><div class="line">// with it.</div><div class="line">//</div><div class="line">// -rac_command is an addition to NSButton. The button will send itself on that</div><div class="line">// command whenever it&#39;s pressed.</div><div class="line">self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {</div><div class="line">    NSLog(@&quot;button was pressed!&quot;);</div><div class="line">    return [RACSignal empty];</div><div class="line">}];</div></div><!-- fragment --><p>Or asynchronous network operations:</p>
<div class="fragment"><div class="line">// Hooks up a &quot;Log in&quot; button to log in over the network.</div><div class="line">//</div><div class="line">// This block will be run whenever the login command is executed, starting</div><div class="line">// the login process.</div><div class="line">self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {</div><div class="line">    // The hypothetical -logIn method returns a signal that sends a value when</div><div class="line">    // the network request finishes.</div><div class="line">    return [client logIn];</div><div class="line">}];</div><div class="line"></div><div class="line">// -executionSignals returns a signal that includes the signals returned from</div><div class="line">// the above block, one for each time the command is executed.</div><div class="line">[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {</div><div class="line">    // Log a message whenever we log in successfully.</div><div class="line">    [loginSignal subscribeCompleted:^{</div><div class="line">        NSLog(@&quot;Logged in successfully!&quot;);</div><div class="line">    }];</div><div class="line">}];</div><div class="line"></div><div class="line">// Executes the login command when the button is pressed.</div><div class="line">self.loginButton.rac_command = self.loginCommand;</div></div><!-- fragment --><p>Signals can also represent timers, other UI events, or anything else that changes over time.</p>
<p>Using signals for asynchronous operations makes it possible to build up more complex behavior by chaining and transforming those signals. Work can easily be triggered after a group of operations completes:</p>
<div class="fragment"><div class="line">// Performs 2 network operations and logs a message to the console when they are</div><div class="line">// both completed.</div><div class="line">//</div><div class="line">// +merge: takes an array of signals and returns a new RACSignal that passes</div><div class="line">// through the values of all of the signals and completes when all of the</div><div class="line">// signals complete.</div><div class="line">//</div><div class="line">// -subscribeCompleted: will execute the block when the signal completes.</div><div class="line">[[RACSignal </div><div class="line">    merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]] </div><div class="line">    subscribeCompleted:^{</div><div class="line">        NSLog(@&quot;They&#39;re both done!&quot;);</div><div class="line">    }];</div></div><!-- fragment --><p>Signals can be chained to sequentially execute asynchronous operations, instead of nesting callbacks with blocks. This is similar to how <a href="http://en.wikipedia.org/wiki/Futures_and_promises">futures and promises</a> are usually used:</p>
<div class="fragment"><div class="line">// Logs in the user, then loads any cached messages, then fetches the remaining</div><div class="line">// messages from the server. After that&#39;s all done, logs a message to the</div><div class="line">// console.</div><div class="line">//</div><div class="line">// The hypothetical -logInUser methods returns a signal that completes after</div><div class="line">// logging in.</div><div class="line">//</div><div class="line">// -flattenMap: will execute its block whenever the signal sends a value, and</div><div class="line">// returns a new RACSignal that merges all of the signals returned from the block</div><div class="line">// into a single signal.</div><div class="line">[[[[client </div><div class="line">    logInUser] </div><div class="line">    flattenMap:^(User *user) {</div><div class="line">        // Return a signal that loads cached messages for the user.</div><div class="line">        return [client loadCachedMessagesForUser:user];</div><div class="line">    }]</div><div class="line">    flattenMap:^(NSArray *messages) {</div><div class="line">        // Return a signal that fetches any remaining messages.</div><div class="line">        return [client fetchMessagesAfterMessage:messages.lastObject];</div><div class="line">    }]</div><div class="line">    subscribeNext:^(NSArray *newMessages) {</div><div class="line">        NSLog(@&quot;New messages: %@&quot;, newMessages);</div><div class="line">    } completed:^{</div><div class="line">        NSLog(@&quot;Fetched all messages.&quot;);</div><div class="line">    }];</div></div><!-- fragment --><p>RAC even makes it easy to bind to the result of an asynchronous operation:</p>
<div class="fragment"><div class="line">// Creates a one-way binding so that self.imageView.image will be set as the user&#39;s</div><div class="line">// avatar as soon as it&#39;s downloaded.</div><div class="line">//</div><div class="line">// The hypothetical -fetchUserWithUsername: method returns a signal which sends</div><div class="line">// the user.</div><div class="line">//</div><div class="line">// -deliverOn: creates new signals that will do their work on other queues. In</div><div class="line">// this example, it&#39;s used to move work to a background queue and then back to the main thread.</div><div class="line">//</div><div class="line">// -map: calls its block with each user that&#39;s fetched and returns a new</div><div class="line">// RACSignal that sends values returned from the block.</div><div class="line">RAC(self.imageView, image) = [[[[client </div><div class="line">    fetchUserWithUsername:@&quot;joshaber&quot;]</div><div class="line">    deliverOn:[RACScheduler scheduler]]</div><div class="line">    map:^(User *user) {</div><div class="line">        // Download the avatar (this is done on a background queue).</div><div class="line">        return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];</div><div class="line">    }]</div><div class="line">    // Now the assignment will be done on the main thread.</div><div class="line">    deliverOn:RACScheduler.mainThreadScheduler];</div></div><!-- fragment --><p>That demonstrates some of what RAC can do, but it doesn't demonstrate why RAC is so powerful. It's hard to appreciate RAC from README-sized examples, but it makes it possible to write code with less state, less boilerplate, better code locality, and better expression of intent.</p>
<p>For more sample code, check out <a href="https://github.com/AshFurrow/C-41">C-41</a> or <a href="https://github.com/jspahrsummers/GroceryList">GroceryList</a>, which are real iOS apps written using ReactiveCocoa. Additional information about RAC can be found in the [Documentation][] folder.</p>
<h2>When to use ReactiveCocoa</h2>
<p>Upon first glance, ReactiveCocoa is very abstract, and it can be difficult to understand how to apply it to concrete problems.</p>
<p>Here are some of the use cases that RAC excels at.</p>
<h3>Handling asynchronous or event-driven data sources</h3>
<p>Much of Cocoa programming is focused on reacting to user events or changes in application state. Code that deals with such events can quickly become very complex and spaghetti-like, with lots of callbacks and state variables to handle ordering issues.</p>
<p>Patterns that seem superficially different, like UI callbacks, network responses, and KVO notifications, actually have a lot in common. <a href="ReactiveCocoa/RACSignal.h">RACSignal</a> unifies all these different APIs so that they can be composed together and manipulated in the same way.</p>
<p>For example, the following code:</p>
<div class="fragment"><div class="line">static void *ObservationContext = &amp;ObservationContext;</div><div class="line"></div><div class="line">- (void)viewDidLoad {</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    [LoginManager.sharedManager addObserver:self forKeyPath:@&quot;loggingIn&quot; options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext];</div><div class="line">    [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];</div><div class="line"></div><div class="line">    [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];</div><div class="line">    [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];</div><div class="line">    [self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">}</div><div class="line"></div><div class="line">- (void)dealloc {</div><div class="line">    [LoginManager.sharedManager removeObserver:self forKeyPath:@&quot;loggingIn&quot; context:ObservationContext];</div><div class="line">    [NSNotificationCenter.defaultCenter removeObserver:self];</div><div class="line">}</div><div class="line"></div><div class="line">- (void)updateLogInButton {</div><div class="line">    BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0;</div><div class="line">    BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn;</div><div class="line">    self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;</div><div class="line">}</div><div class="line"></div><div class="line">- (IBAction)logInPressed:(UIButton *)sender {</div><div class="line">    [[LoginManager sharedManager]</div><div class="line">        logInWithUsername:self.usernameTextField.text</div><div class="line">        password:self.passwordTextField.text</div><div class="line">        success:^{</div><div class="line">            self.loggedIn = YES;</div><div class="line">        } failure:^(NSError *error) {</div><div class="line">            [self presentError:error];</div><div class="line">        }];</div><div class="line">}</div><div class="line"></div><div class="line">- (void)loggedOut:(NSNotification *)notification {</div><div class="line">    self.loggedIn = NO;</div><div class="line">}</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {</div><div class="line">    if (context == ObservationContext) {</div><div class="line">        [self updateLogInButton];</div><div class="line">    } else {</div><div class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>… could be expressed in RAC like so:</p>
<div class="fragment"><div class="line">- (void)viewDidLoad {</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    @weakify(self);</div><div class="line"></div><div class="line">    RAC(self.logInButton, enabled) = [RACSignal</div><div class="line">        combineLatest:@[</div><div class="line">            self.usernameTextField.rac_textSignal,</div><div class="line">            self.passwordTextField.rac_textSignal,</div><div class="line">            RACObserve(LoginManager.sharedManager, loggingIn),</div><div class="line">            RACObserve(self, loggedIn)</div><div class="line">        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {</div><div class="line">            return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue);</div><div class="line">        }];</div><div class="line"></div><div class="line">    [[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) {</div><div class="line">        @strongify(self);</div><div class="line"></div><div class="line">        RACSignal *loginSignal = [LoginManager.sharedManager</div><div class="line">            logInWithUsername:self.usernameTextField.text</div><div class="line">            password:self.passwordTextField.text];</div><div class="line"></div><div class="line">            [loginSignal subscribeError:^(NSError *error) {</div><div class="line">                @strongify(self);</div><div class="line">                [self presentError:error];</div><div class="line">            } completed:^{</div><div class="line">                @strongify(self);</div><div class="line">                self.loggedIn = YES;</div><div class="line">            }];</div><div class="line">    }];</div><div class="line"></div><div class="line">    RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter</div><div class="line">        rac_addObserverForName:UserDidLogOutNotification object:nil]</div><div class="line">        mapReplace:@NO];</div><div class="line">}</div></div><!-- fragment --><h3>Chaining dependent operations</h3>
<p>Dependencies are most often found in network requests, where a previous request to the server needs to complete before the next one can be constructed, and so on:</p>
<div class="fragment"><div class="line">[client logInWithSuccess:^{</div><div class="line">    [client loadCachedMessagesWithSuccess:^(NSArray *messages) {</div><div class="line">        [client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) {</div><div class="line">            NSLog(@&quot;Fetched all messages.&quot;);</div><div class="line">        } failure:^(NSError *error) {</div><div class="line">            [self presentError:error];</div><div class="line">        }];</div><div class="line">    } failure:^(NSError *error) {</div><div class="line">        [self presentError:error];</div><div class="line">    }];</div><div class="line">} failure:^(NSError *error) {</div><div class="line">    [self presentError:error];</div><div class="line">}];</div></div><!-- fragment --><p>ReactiveCocoa makes this pattern particularly easy:</p>
<div class="fragment"><div class="line">[[[[client logIn]</div><div class="line">    then:^{</div><div class="line">        return [client loadCachedMessages];</div><div class="line">    }]</div><div class="line">    flattenMap:^(NSArray *messages) {</div><div class="line">        return [client fetchMessagesAfterMessage:messages.lastObject];</div><div class="line">    }]</div><div class="line">    subscribeError:^(NSError *error) {</div><div class="line">        [self presentError:error];</div><div class="line">    } completed:^{</div><div class="line">        NSLog(@&quot;Fetched all messages.&quot;);</div><div class="line">    }];</div></div><!-- fragment --><h3>Parallelizing independent work</h3>
<p>Working with independent data sets in parallel and then combining them into a final result is non-trivial in Cocoa, and often involves a lot of synchronization:</p>
<div class="fragment"><div class="line">__block NSArray *databaseObjects;</div><div class="line">__block NSArray *fileContents;</div><div class="line"></div><div class="line">NSOperationQueue *backgroundQueue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *databaseOperation = [NSBlockOperation blockOperationWithBlock:^{</div><div class="line">    databaseObjects = [databaseClient fetchObjectsMatchingPredicate:predicate];</div><div class="line">}];</div><div class="line"></div><div class="line">NSBlockOperation *filesOperation = [NSBlockOperation blockOperationWithBlock:^{</div><div class="line">    NSMutableArray *filesInProgress = [NSMutableArray array];</div><div class="line">    for (NSString *path in files) {</div><div class="line">        [filesInProgress addObject:[NSData dataWithContentsOfFile:path]];</div><div class="line">    }</div><div class="line"></div><div class="line">    fileContents = [filesInProgress copy];</div><div class="line">}];</div><div class="line"></div><div class="line">NSBlockOperation *finishOperation = [NSBlockOperation blockOperationWithBlock:^{</div><div class="line">    [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];</div><div class="line">    NSLog(@&quot;Done processing&quot;);</div><div class="line">}];</div><div class="line"></div><div class="line">[finishOperation addDependency:databaseOperation];</div><div class="line">[finishOperation addDependency:filesOperation];</div><div class="line">[backgroundQueue addOperation:databaseOperation];</div><div class="line">[backgroundQueue addOperation:filesOperation];</div><div class="line">[backgroundQueue addOperation:finishOperation];</div></div><!-- fragment --><p>The above code can be cleaned up and optimized by simply composing signals:</p>
<div class="fragment"><div class="line">RACSignal *databaseSignal = [[databaseClient</div><div class="line">    fetchObjectsMatchingPredicate:predicate]</div><div class="line">    subscribeOn:[RACScheduler scheduler]];</div><div class="line"></div><div class="line">RACSignal *fileSignal = [RACSignal startEagerlyWithScheduler:[RACScheduler scheduler] block:^(id&lt;RACSubscriber&gt; subscriber) {</div><div class="line">    NSMutableArray *filesInProgress = [NSMutableArray array];</div><div class="line">    for (NSString *path in files) {</div><div class="line">        [filesInProgress addObject:[NSData dataWithContentsOfFile:path]];</div><div class="line">    }</div><div class="line"></div><div class="line">    [subscriber sendNext:[filesInProgress copy]];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">}];</div><div class="line"></div><div class="line">[[RACSignal</div><div class="line">    combineLatest:@[ databaseSignal, fileSignal ]</div><div class="line">    reduce:^ id (NSArray *databaseObjects, NSArray *fileContents) {</div><div class="line">        [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];</div><div class="line">        return nil;</div><div class="line">    }]</div><div class="line">    subscribeCompleted:^{</div><div class="line">        NSLog(@&quot;Done processing&quot;);</div><div class="line">    }];</div></div><!-- fragment --><h3>Simplifying collection transformations</h3>
<p>Higher-order functions like <code>map</code>, <code>filter</code>, <code>fold</code>/<code>reduce</code> are sorely missing from Foundation, leading to loop-focused code like this:</p>
<div class="fragment"><div class="line">NSMutableArray *results = [NSMutableArray array];</div><div class="line">for (NSString *str in strings) {</div><div class="line">    if (str.length &lt; 2) {</div><div class="line">        continue;</div><div class="line">    }</div><div class="line"></div><div class="line">    NSString *newString = [str stringByAppendingString:@&quot;foobar&quot;];</div><div class="line">    [results addObject:newString];</div><div class="line">}</div></div><!-- fragment --><p><a href="ReactiveCocoa/RACSequence.h">RACSequence</a> allows any Cocoa collection to be manipulated in a uniform and declarative way:</p>
<div class="fragment"><div class="line">RACSequence *results = [[strings.rac_sequence</div><div class="line">    filter:^ BOOL (NSString *str) {</div><div class="line">        return str.length &gt;= 2;</div><div class="line">    }]</div><div class="line">    map:^(NSString *str) {</div><div class="line">        return [str stringByAppendingString:@&quot;foobar&quot;];</div><div class="line">    }];</div></div><!-- fragment --><h2>System Requirements</h2>
<p>ReactiveCocoa supports OS X 10.8+ and iOS 8.0+.</p>
<h2>Importing ReactiveCocoa</h2>
<p>To add RAC to your application:</p>
<ol type="1">
<li>Add the ReactiveCocoa repository as a submodule of your application's repository.</li>
</ol>
<ol type="1">
<li>Run <code>script/bootstrap</code> from within the ReactiveCocoa folder.</li>
</ol>
<ol type="1">
<li>Drag and drop <code>ReactiveCocoa.xcodeproj</code> into your application's Xcode project or workspace.</li>
</ol>
<ol type="1">
<li>On the "Build Phases" tab of your application target, add RAC to the "Link
    Binary With Libraries" phase.<ul>
<li><b>On iOS</b>, add <code>libReactiveCocoa-iOS.a</code>.</li>
<li><b>On OS X</b>, add <code>ReactiveCocoa.framework</code>. RAC must also be added to any "Copy Frameworks" build phase. If you don't already have one, simply add a "Copy Files" build phase and target the "Frameworks" destination.</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Add <code>"$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include" </code> to the "Header Search Paths" build setting (this is only necessary for archive builds, but it has no negative effect otherwise).</li>
</ol>
<ol type="1">
<li><b>For iOS targets</b>, add <code>-ObjC</code> to the "Other Linker Flags" build setting.</li>
</ol>
<ol type="1">
<li><b>If you added RAC to a project (not a workspace)</b>, you will also need to add the appropriate RAC target to the "Target Dependencies" of your application.</li>
</ol>
<p>If you would prefer to use <a href="http://cocoapods.org">CocoaPods</a>, there are some <a href="https://github.com/CocoaPods/Specs/tree/master/Specs/ReactiveCocoa">ReactiveCocoa podspecs</a> that have been generously contributed by third parties.</p>
<p>To see a project already set up with RAC, check out <a href="https://github.com/AshFurrow/C-41">C-41</a> or <a href="https://github.com/jspahrsummers/GroceryList">GroceryList</a>, which are real iOS apps written using ReactiveCocoa.</p>
<h2>Standalone Development</h2>
<p>If you’re working on RAC in isolation instead of integrating it into another project, you’ll want to open <code>ReactiveCocoa.xcworkspace</code> and not the <code>.xcodeproj</code>.</p>
<h2>More Info</h2>
<p>ReactiveCocoa is based on .NET's <a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a> (Rx). Most of the principles of Rx apply to RAC as well. There are some really good Rx resources out there:</p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/hh242985.aspx">Reactive Extensions MSDN entry</a></li>
<li><a href="http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html">Reactive Extensions for .NET Introduction</a></li>
<li><a href="http://channel9.msdn.com/tags/Rx/">Rx - Channel 9 videos</a></li>
<li><a href="http://rxwiki.wikidot.com/">Reactive Extensions wiki</a></li>
<li><a href="http://rxwiki.wikidot.com/101samples">101 Rx Samples</a></li>
<li><a href="http://www.amazon.com/Programming-Reactive-Extensions-Jesse-Liberty/dp/1430237473">Programming Reactive Extensions and LINQ</a></li>
</ul>
<p>RAC and Rx are both frameworks inspired by functional reactive programming. Here are some resources related to FRP:</p>
<ul>
<li><a href="http://elm-lang.org/learn/What-is-FRP.elm">What is FRP? - Elm Language</a></li>
<li><a href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631">What is Functional Reactive Programming - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525">Specification for a Functional Reactive Language - Stack Overflow</a></li>
<li><a href="http://elm-lang.org/learn/Escape-from-Callback-Hell.elm">Escape from Callback Hell</a></li>
<li><a href="https://www.coursera.org/course/reactive">Principles of Reactive Programming on Coursera</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
