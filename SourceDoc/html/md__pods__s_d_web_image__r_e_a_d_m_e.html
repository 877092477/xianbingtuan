<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FnuoOS导购返利: Web Image</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon120.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FnuoOS导购返利
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">FnuoOS导购返利模板</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Web Image </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/rs/SDWebImage"></a> <a href="http://cocoadocs.org/docsets/SDWebImage/"></a> <a href="http://cocoadocs.org/docsets/SDWebImage/"></a> <a href="https://www.apache.org/licenses/LICENSE-2.0.html"></a> <a href="https://www.versioneye.com/objective-c/sdwebimage/3.3"></a> <a href="https://www.versioneye.com/objective-c/sdwebimage/references"></a> <a href="https://github.com/rs/SDWebImage"></a></p>
<p>This library provides a category for UIImageView with support for remote images coming from the web.</p>
<p>It provides:</p>
<ul>
<li>An <code>UIImageView</code> category adding web image and cache management to the Cocoa Touch framework</li>
<li>An asynchronous image downloader</li>
<li>An asynchronous memory + disk image caching with automatic cache expiration handling</li>
<li>Animated GIF support</li>
<li>WebP format support</li>
<li>A background image decompression</li>
<li>A guarantee that the same URL won't be downloaded several times</li>
<li>A guarantee that bogus URLs won't be retried again and again</li>
<li>A guarantee that main thread will never be blocked</li>
<li>Performances!</li>
<li>Use GCD and ARC</li>
<li>Arm64 support</li>
</ul>
<p>NOTE: The version 3.0 of SDWebImage isn't fully backward compatible with 2.0 and requires iOS 5.1.1 minimum deployment version. If you need iOS &lt; 5.0 support, please use the last <a href="https://github.com/rs/SDWebImage/tree/2.0-compat">2.0 version</a>.</p>
<p><a href="https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F">How is SDWebImage better than X?</a></p>
<h2>Who Use It </h2>
<p>Find out <a href="https://github.com/rs/SDWebImage/wiki/Who-Uses-SDWebImage">who uses SDWebImage</a> and add your app to the list.</p>
<h2>How To Use </h2>
<p>API documentation is available at <a href="http://cocoadocs.org/docsets/SDWebImage/">CocoaDocs - SDWebImage</a></p>
<h3>Using UIImageView+WebCache category with UITableView</h3>
<p>Just #import the UIImageView+WebCache.h header, and call the sd_setImageWithURL:placeholderImage: method from the tableView:cellForRowAtIndexPath: <a class="el" href="class_u_i_table_view_data_source-p.html">UITableViewDataSource</a> method. Everything will be handled for you, from async downloads to caching management.</p>
<div class="fragment"><div class="line">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {</div><div class="line">    static NSString *MyIdentifier = @&quot;MyIdentifier&quot;;</div><div class="line"></div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</div><div class="line">    if (cell == nil) {</div><div class="line">        cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault</div><div class="line">                                       reuseIdentifier:MyIdentifier] autorelease];</div><div class="line">    }</div><div class="line"></div><div class="line">    // Here we use the new provided sd_setImageWithURL: method to load the web image</div><div class="line">    [cell.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://www.domain.com/path/to/image.jpg&quot;]</div><div class="line">                      placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];</div><div class="line"></div><div class="line">    cell.textLabel.text = @&quot;My Text&quot;;</div><div class="line">    return cell;</div><div class="line">}</div></div><!-- fragment --><h3>Using blocks</h3>
<p>With blocks, you can be notified about the image download progress and whenever the image retrieval has completed with success or not:</p>
<div class="fragment"><div class="line">// Here we use the new provided sd_setImageWithURL: method to load the web image</div><div class="line">[cell.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://www.domain.com/path/to/image.jpg&quot;]</div><div class="line">                      placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]</div><div class="line">                             completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {</div><div class="line">                                ... completion code here ...</div><div class="line">                             }];</div></div><!-- fragment --><p>Note: neither your success nor failure block will be call if your image request is canceled before completion.</p>
<h3>Using <a class="el" href="interface_s_d_web_image_manager.html">SDWebImageManager</a></h3>
<p>The <a class="el" href="interface_s_d_web_image_manager.html">SDWebImageManager</a> is the class behind the UIImageView+WebCache category. It ties the asynchronous downloader with the image cache store. You can use this class directly to benefit from web image downloading with caching in another context than a UIView (ie: with Cocoa).</p>
<p>Here is a simple example of how to use <a class="el" href="interface_s_d_web_image_manager.html">SDWebImageManager</a>:</p>
<div class="fragment"><div class="line">SDWebImageManager *manager = [SDWebImageManager sharedManager];</div><div class="line">[manager downloadImageWithURL:imageURL</div><div class="line">                      options:0</div><div class="line">                     progress:^(NSInteger receivedSize, NSInteger expectedSize) {</div><div class="line">                         // progression tracking code</div><div class="line">                     }</div><div class="line">                     completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {</div><div class="line">                         if (image) {</div><div class="line">                             // do something with image</div><div class="line">                         }</div><div class="line">                     }];</div></div><!-- fragment --><h3>Using Asynchronous Image Downloader Independently</h3>
<p>It's also possible to use the async image downloader independently:</p>
<div class="fragment"><div class="line">SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</div><div class="line">[downloader downloadImageWithURL:imageURL</div><div class="line">                         options:0</div><div class="line">                        progress:^(NSInteger receivedSize, NSInteger expectedSize) {</div><div class="line">                            // progression tracking code</div><div class="line">                        }</div><div class="line">                       completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) {</div><div class="line">                            if (image &amp;&amp; finished) {</div><div class="line">                                // do something with image</div><div class="line">                            }</div><div class="line">                        }];</div></div><!-- fragment --><h3>Using Asynchronous Image Caching Independently</h3>
<p>It is also possible to use the async based image cache store independently. <a class="el" href="interface_s_d_image_cache.html">SDImageCache</a> maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn't add unnecessary latency to the UI.</p>
<p>The <a class="el" href="interface_s_d_image_cache.html">SDImageCache</a> class provides a singleton instance for convenience but you can create your own instance if you want to create separated cache namespace.</p>
<p>To lookup the cache, you use the <code>queryDiskCacheForKey:done:</code> method. If the method returns nil, it means the cache doesn't currently own the image. You are thus responsible for generating and caching it. The cache key is an application unique identifier for the image to cache. It is generally the absolute URL of the image.</p>
<div class="fragment"><div class="line">SDImageCache *imageCache = [[SDImageCache alloc] initWithNamespace:@&quot;myNamespace&quot;];</div><div class="line">[imageCache queryDiskCacheForKey:myCacheKey done:^(UIImage *image) {</div><div class="line">    // image is not nil if image was found</div><div class="line">}];</div></div><!-- fragment --><p>By default <a class="el" href="interface_s_d_image_cache.html">SDImageCache</a> will lookup the disk cache if an image can't be found in the memory cache. You can prevent this from happening by calling the alternative method <code>imageFromMemoryCacheForKey:</code>.</p>
<p>To store an image into the cache, you use the storeImage:forKey: method:</p>
<div class="fragment"><div class="line">[[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];</div></div><!-- fragment --><p>By default, the image will be stored in memory cache as well as on disk cache (asynchronously). If you want only the memory cache, use the alternative method storeImage:forKey:toDisk: with a negative third argument.</p>
<h3>Using cache key filter</h3>
<p>Sometime, you may not want to use the image URL as cache key because part of the URL is dynamic (i.e.: for access control purpose). <a class="el" href="interface_s_d_web_image_manager.html">SDWebImageManager</a> provides a way to set a cache key filter that takes the NSURL as input, and output a cache key NSString.</p>
<p>The following example sets a filter in the application delegate that will remove any query-string from the URL before to use it as a cache key:</p>
<div class="fragment"><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {</div><div class="line">    SDWebImageManager.sharedManager.cacheKeyFilter = ^(NSURL *url) {</div><div class="line">        url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</div><div class="line">        return [url absoluteString];</div><div class="line">    };</div><div class="line"></div><div class="line">    // Your app init code...</div><div class="line">    return YES;</div><div class="line">}</div></div><!-- fragment --><h2>Common Problems </h2>
<h3>Using dynamic image size with UITableViewCell</h3>
<p>UITableView determines the size of the image by the first image set for a cell. If your remote images don't have the same size as your placeholder image, you may experience strange anamorphic scaling issue. The following article gives a way to workaround this issue:</p>
<p><a href="http://www.wrichards.com/blog/2011/11/sdwebimage-fixed-width-cell-images/">http://www.wrichards.com/blog/2011/11/sdwebimage-fixed-width-cell-images/</a></p>
<h3>Handle image refresh</h3>
<p>SDWebImage does very aggressive caching by default. It ignores all kind of caching control header returned by the HTTP server and cache the returned images with no time restriction. It implies your images URLs are static URLs pointing to images that never change. If the pointed image happen to change, some parts of the URL should change accordingly.</p>
<p>If you don't control the image server you're using, you may not be able to change the URL when its content is updated. This is the case for Facebook avatar URLs for instance. In such case, you may use the <code>SDWebImageRefreshCached</code> flag. This will slightly degrade the performance but will respect the HTTP caching control headers:</p>
<div class="fragment"><div class="line">[imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;https://graph.facebook.com/olivier.poitrey/picture&quot;]</div><div class="line">                 placeholderImage:[UIImage imageNamed:@&quot;avatar-placeholder.png&quot;]</div><div class="line">                          options:SDWebImageRefreshCached];</div></div><!-- fragment --><h3>Add a progress indicator</h3>
<p>See this category: <a href="https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage">https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage</a></p>
<h2>Installation </h2>
<p>There are three ways to use SDWebImage in your project:</p><ul>
<li>using Cocoapods</li>
<li>copying all the files into your project</li>
<li>importing the project as a static library</li>
</ul>
<h3>Installation with CocoaPods</h3>
<p><a href="http://cocoapods.org/">CocoaPods</a> is a dependency manager for Objective-C, which automates and simplifies the process of using 3rd-party libraries in your projects. See the <a href="http://cocoapods.org/#get_started">Get Started</a> section for more details.</p>
<p>#### Podfile </p><div class="fragment"><div class="line">platform :ios, &#39;6.1&#39;</div><div class="line">pod &#39;SDWebImage&#39;, &#39;~&gt;3.7&#39;</div></div><!-- fragment --><p>If you are using Swift, be sure to add <code>use_frameworks!</code> and set your target to iOS 8+: </p><div class="fragment"><div class="line">platform :ios, &#39;8.0&#39;</div><div class="line">use_frameworks!</div></div><!-- fragment --><h4>Subspecs</h4>
<p>There are 3 subspecs available now: <code>Core</code>, <code>MapKit</code> and <code>WebP</code> (this means you can install only some of the SDWebImage modules. By default, you get just <code>Core</code>, so if you need <code>WebP</code>, you need to specify it).</p>
<p>Podfile example: </p><div class="fragment"><div class="line">pod &#39;SDWebImage/WebP&#39;</div></div><!-- fragment --><h3>Installation with Carthage (iOS 8+)</h3>
<p><a href="https://github.com/Carthage/Carthage">Carthage</a> is a lightweight dependency manager for Swift and Objective-C. It leverages CocoaTouch modules and is less invasive than CocoaPods.</p>
<p>To install with carthage, follow the instruction on <a href="https://github.com/Carthage/Carthage">Carthage</a></p>
<p>#### Cartfile </p><div class="fragment"><div class="line">github &quot;rs/SDWebImage&quot;</div></div><!-- fragment --><h4>Usage</h4>
<p>Swift</p>
<p>If you installed using CocoaPods: </p><div class="fragment"><div class="line">import SDWebImage</div></div><!-- fragment --><p>If you installed manually: </p><div class="fragment"><div class="line">import WebImage</div></div><!-- fragment --><p>Objective-C</p>
<div class="fragment"><div class="line">@import WebImage;</div></div><!-- fragment --><h3>Installation by cloning the repository</h3>
<p>In order to gain access to all the files from the repository, you should clone it. </p><div class="fragment"><div class="line">git clone --recursive https://github.com/rs/SDWebImage.git</div></div><!-- fragment --><h3>Add the SDWebImage project to your project</h3>
<ul>
<li>Download and unzip the last version of the framework from the <a href="https://github.com/rs/SDWebImage/releases">download page</a></li>
<li>Right-click on the project navigator and select "Add Files to "Your Project":</li>
<li>In the dialog, select SDWebImage.framework:</li>
<li>Check the "Copy items into destination group's folder (if needed)" checkbox</li>
</ul>
<h3>Add dependencies</h3>
<ul>
<li>In you application project app’s target settings, find the "Build Phases" section and open the "Link Binary With Libraries" block:</li>
<li>Click the "+" button again and select the "ImageIO.framework", this is needed by the progressive download feature:</li>
</ul>
<h3>Add Linker Flag</h3>
<p>Open the "Build Settings" tab, in the "Linking" section, locate the "Other Linker Flags" setting and add the "-ObjC" flag:</p>
<div class="image">
<img src="http://dl.dropbox.com/u/123346/SDWebImage/10_other_linker_flags.jpg" alt="Other Linker Flags"/>
</div>
<p>Alternatively, if this causes compilation problems with frameworks that extend optional libraries, such as Parse, RestKit or opencv2, instead of the -ObjC flag use: </p><div class="fragment"><div class="line">-force_load SDWebImage.framework/Versions/Current/SDWebImage</div></div><!-- fragment --><p>If you're using Cocoa Pods and have any frameworks that extend optional libraries, such as Parsen RestKit or opencv2, instead of the -ObjC flag use: </p><div class="fragment"><div class="line">-force_load $(TARGET_BUILD_DIR)/libPods.a</div></div><!-- fragment --><p> and this: </p><div class="fragment"><div class="line">$(inherited)</div></div><!-- fragment --><h3>Import headers in your source files</h3>
<p>In the source files where you need to use the library, import the header file:</p>
<div class="fragment"><div class="line">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;</div></div><!-- fragment --><h3>Build Project</h3>
<p>At this point your workspace should build without error. If you are having problem, post to the Issue and the community can help you solve it.</p>
<h2>Future Enhancements </h2>
<ul>
<li>LRU memory cache cleanup instead of reset on memory warning</li>
</ul>
<h2>Licenses</h2>
<p>All source code is licensed under the <a href="https://raw.github.com/rs/SDWebImage/master/LICENSE">MIT License</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
